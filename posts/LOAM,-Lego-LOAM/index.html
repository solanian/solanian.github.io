<!DOCTYPE html> <script type="text/x-mathjax-config"> MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}}); </script> <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"> </script><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="LOAM, Lego-LOAM 정리" /><meta property="og:locale" content="en" /><meta name="description" content="LOAM, Lego-LOAM" /><meta property="og:description" content="LOAM, Lego-LOAM" /><link rel="canonical" href="https://solanian.github.io/posts/LOAM,-Lego-LOAM/" /><meta property="og:url" content="https://solanian.github.io/posts/LOAM,-Lego-LOAM/" /><meta property="og:site_name" content="I want to know everything" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-11-24T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="LOAM, Lego-LOAM 정리" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-10T19:03:47+09:00","datePublished":"2020-11-24T00:00:00+09:00","description":"LOAM, Lego-LOAM","headline":"LOAM, Lego-LOAM 정리","mainEntityOfPage":{"@type":"WebPage","@id":"https://solanian.github.io/posts/LOAM,-Lego-LOAM/"},"url":"https://solanian.github.io/posts/LOAM,-Lego-LOAM/"}</script><title>LOAM, Lego-LOAM 정리 | I want to know everything</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="I want to know everything"><meta name="application-name" content="I want to know everything"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="stylesheet" href="/assets/css/academicons.css"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> </a></div><div class="site-title mt-3"> <a href="/">I want to know everything</a></div><div class="site-subtitle font-italic">academic notes, thoughts, reviews</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="https://drive.google.com/file/d/1rIuUuGCkeIdNCTUC6p3cKCzRFvuR7Fxk/view?usp=sharing" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>CURRICULUM VITAE</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/solanian" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sorld0603','snu.ac.kr'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="https://www.linkedin.com/in/dongseong-seo-64a3471aa" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href="https://scholar.google.com/citations?user=B7-29akAAAAJ" aria-label="googlescholar" target="_blank" rel="noopener"> <i class="ai ai-google-scholar-square"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>LOAM, Lego-LOAM 정리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>LOAM, Lego-LOAM 정리</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1606143600" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Nov 24, 2020 </em> </span> <span> Updated <em class="" data-ts="1660125827" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Aug 10, 2022 </em> </span><div class="d-flex justify-content-between"> <span> By <em> <a href="https://github.com/solanian">Dongseong Seo</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3097 words"> <em>17 min</em> read</span></div></div></div><div class="post-content"><h1 id="loam-lego-loam">LOAM, Lego-LOAM</h1><p>Lidar Odometry에서 많이 쓰이는 LOAM 계열의 논문들을 리뷰해 보고자 한다.</p><h1 id="loam">LOAM</h1><p>paper: LOAM: Lidar Odometry And Mapping in Real-time (or Low-drift and Real-time Lidar Odometry and Mapping)</p><p>LOAM은 논문 제목대로 Lidar Odometry And Mapping의 줄임말로 high accuracy ranging과 inertial measurement 없이 Low-drfit, Low-computational complexity를 가진 odometry라고 한다.</p><p>Odometry는 아주 복잡한 문제인 SLAM 문제의 일부이며 이 odometry를 아래처럼 두 부분으로 나누어서 해결했다고 한다.</p><ul><li>motion estimation을 위해 높은 frequency로 돌아가지만 신뢰도가 비교적 낮은 odometry<li>위의 알고리즘에 비해 frequency가 낮지만 fine registration을 할 수 있는 mapping</ul><p>LOAM의 전제 시스템은 다음과 같다.</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/637424184118100680.jpeg" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/637424184118100680.jpeg" data-proofer-ignore></p><ol><li>Lidar input이 들어오면 registration을 해서 Lidar odometry를 한다.<li>Odometry의 결과 pose를 이용해 Lidar mapping을 한다.<li>Mapping의 결과와 Odometry의 pose결과를 합쳐서 finagl pose를 얻는다.<ul><li>Lidar Odometry<ul><li><p>Feature Point Extraction</p><p>Registration에 사용되는 feature는 edge와 plane이다. 그래서 point마다 edge point인지 planar point인지를 구별하기 위해서 smoothness를 구해서 이를 판별하였다.</p>\[c=\frac{1}{|S||X^L_{(k, i)}|}||\sum_{j\in S ,\ j \neq i}(X^L_{(k, i)}-X^L_{(k, j)})||\]<p>여기서 $S$는 표현이 애매한데 내가 이해한 바로는 point $i$와 consecutive한 point들의 set이며 양쪽 side를 반반씩 가지고 있는 set리고 한다. LeGO-LOAM 구현코드에서는 양쪽 point 5개씩 사용한것을 봐서는 결국 양쪽에 n개씩 사용한다는 뜻인것 같다. $\begin{vmatrix}S\end{vmatrix},\begin{vmatrix}X^L_{(k,i)}\end{vmatrix}$는 거리, set의 크기에 대한 normalize term역할을 한다.</p><p>그래서 이 maximum $c$들을 edge point 로 minimum c들을 planar point로 한다고 하는데 식을 보면 edge인 경우에 현재 point를 기준으로 consecutive한 point가 어느 한쪽으로 몰려있기 때문에 $c$의 값이 커지고 planar의 경우 평평할수록 현재 point를 지나는 대칭형태의 line이 되므로 값들이 상쇄되어 0에 가까워진다.</p><p>그리고 feature point를 골고루 뽑기 위해 90도씩 4개의 subregion으로 나누고 각각의 region마다 threshold를 만족하는 edge는 최대 2개, planar는 최대 4개를 찾도록 하였다.</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled.png" data-proofer-ignore></p><p>그리고 feature point를 골고루 뽑아야 하므로 주변에 feature point가 존재하면 뽑지 않도록 하였고 occluded region의 boudary또한 실제로는 planar인데 edge로 뽑힐 가능성도 있으므로 뽑지 않으며 laser beam에 parallel한 surface는 대체로 unreliable하므로 이또한 뽑지 않도록 한다. 이런 과정을 통해 edge point와 planar point는 아래와 같이 뽑힌다.</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%201.png" alt="노란색: edge 빨간색: planar" data-proofer-ignore></p><p>노란색: edge 빨간색: planar</p><li><p>Finding Feature Point Correspondence</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%202.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%202.png" data-proofer-ignore></p><p>Feature를 찾았으면 registration을 위해서 서로 다른 scene의 feature들 간에 correpondence를 생성해야한다. $P_{k+1}$에서 찾은 edge와 planar를 $E_{k+1}, H_{k+1}$이라 하면 이 point들에 대해 $P_k$에 있는 point중 nearest point를 찾아 correspondece를 만든다고 한다.</p><p>edge point: $i\in E_{k+1}$에 대해서 $P_k$에서의 nearest point를 $j$라고 하고 edge line을 형성하기 위해서는 2개의 point가 필요하므로 $j$의 consecutive point $l\in P_k$를 구하고 이 $j, l$에 대해 smoothness를 계산해 둘 다 edge point라면 $(j,l)$이 이루는 edge line과 $i$ 사이에 correspondence를 만들고 다음과 같은 식으로 correspondence의 distance를 구한다.</p>\[d_{\epsilon}=\frac{|(\tilde{X}^L_{(k+1,i)}-\bar{X}^L_{(k, j)})\times(\tilde{X}^L_{(k+1,i)}-\bar{X}^L_{(k,l)})|}{|\bar{X}^L_{(k, j)}-\bar{X}^L_{(k,l)}|}\]<p>planar point: $i\in H_{k+1}$에 대해서 $P_k$에서의 nearest point를 $j$라고 하고 plane을 형성하기 위해서는 3개의 point가 필요하므로 세 점이 한 직선을 만들지 않도록 $j$의 nearest neighbor 2개의 $l,m\in P_k$를 구하고 이 $j,l,m$에 대해 smoothness를 계산해 셋 모두 planar point라면 $(j,l,m)$이 이루는 plane과 $i$사이에 correspondence를 만들고 다음과 같은 식으로 correspondence의 distance를 구한다.</p>\[d_H=\frac{|(\tilde{X}^L_{(k+1,i)}-\bar{X}^L_{(k,j)})\{(\bar{X}^L_{(k,j)}-\bar{X}^L_{(k,l)})\times(\bar{X}^L_{(k,j)}-\bar{X}^L_{(k,m)})\}|}{|(\bar{X}^L_{(k,j)}-\bar{X}^L_{(k,l)})\times(\bar{X}^L_{(k,j)}-\bar{X}^L_{(k,m)})|}\]<li><p>Motion Estimation</p><p>위에서 구한 correspondence를 이용해 두 frame사이의 motion estimation을 해야한다. 그런데 lidar point는 모든 point가 동시에 찍혀 나오는것이 아니라 일정한 속도로 sweep을 하면서 한 frame을 완성하는 것이기에 linear interpolation을 해줘야 한다. 그래서 transformation을 구한 시점 $t$에서의 6-DOF transformation을 $T^L_{k+1}=[t_x,t_y,t_z,\theta_x,\theta_y,\theta_z]^T$이라고 하고 transform 하는 point의 index를 $i$라고 하면 point $i$에 한 transformation은 다음과 같다.</p>\[T^L_{(k+1,i)}=\frac{t_i-t_{k+1}}{t-t_{k+1}}T^L_{k+1}\]<p>motion estimation을 위해서는 두 frame에서 찾은 feature들 사이의 transform matrix를 구해야한다. 즉 아래의 식을 만족하는 transformation을 구해야한다.</p>\[X^L_{(k+1,i)}=R\tilde{X}^L_{(k+1,i)}+T^L_{(k+1,i)}(1:3)\]<p>여기서 $R$은 optimization을 위해서 $T^L_{(k+1,i)}(4:6)$을 Rodrigues formula를 통해서 구한 $\omega$의 skew symmetric matrix이다.</p><p>위의 문제를 optimization problem으로 풀기 위해 correpondence의 거리가 가까워진다는 것은 제대로 registration(motion estimation)이 이뤄졌다는 의미이므로 아래와 같이 edge correspondence와 planar correspondence를 cost로 삼는다.</p>\[f_{E}(X^L_{(k+1,i)},T^L_{k+1})=d_E, i\in E_{k+1} \\ f_{H}(X^L_{(k+1,i)},T^L_{k+1})=d_H, i\in H_{k+1} \\ \rightarrow f(T^L_{k+1})=d\]<p>optimization에 사용된 알고리즘은 Levenberg-Marquardt이다.</p>\[T^L_{k+1}\leftarrow T^L_{k+1}-(J^TJ+\lambda diag(J^TJ))^{-1}J^Td\]<li><p>Lidar Odometry Algorithm</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%203.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%203.png" data-proofer-ignore></p><p>lidar odometry에 사용된 알고리즘을 정리하자면 위와 같다. 앞에 소개한 방법론들을 순차적으로 진행하여 얻은 transform을 통해 odometry를 한다.</p></ul></ul></ol><ul><li><p>Lidar Mapping</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%204.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%204.png" data-proofer-ignore></p><p>lidar mapping은 odometry보다 더 낮은 빈도로 실행되고 sweep이 완성된 후에만 실행된다. odometry에서 구한 motion으로 untwist된 point cloud \(\bar{P}_{k+1}\)을 world coordinate상의 map에 registration하는 과정이다.</p><p>$Q_k$를 sweep $k$가 끝난 시점에서의 pose주변의 cubic area내에 존재하는 map point들의 set이라 하고 $\bar{P}_{k+1}$을 mapping을 통해서 가장 최근에 얻은 transformation인 $T^W_k$으로 transform한 point를 \(\bar{Q}_{k+1}\)이라 하면 odometry에서 한 것처럼 feature extraction, finding correspondence, motion estimation을 통해서 \(\bar{Q}_{k+1}\)을 \(Q_k\)에 registration을 한다.</p><p>mapping에서 \(\bar{Q}_{k+1}\)에 대한 feature extration은 이미 odomery에서 했기 때문에 그대로 사용한다. odometry가 10Hz로 돌아가고 mapping이 1Hz로 돌아가기 때문에 10배의 feature를 사용하게 된다.</p><p>correspondence 생성은 $\bar{Q}_{k+1}$의 각 feature point마다 주변에 존재하는 $Q_k$의 point의 set $S’$을 구하고 $S$에 대해서 matrix decomposition을 통해 eigenvalue와 eigenvector를 구하고 eigenvalue에서 dominant한 value의 갯수가 2개면 plane, 1개면 edge라고 판별하고 edge line과 planar patch의 position은 $S’$의 geometric center로 삼아서 feature point과 이 center사이의 corresopndence를 생성한다.</p><p>optimization은 마찬가지로 Levenberg-Marquardt를 사용해서 transformation을 구한다.</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%205.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%205.png" data-proofer-ignore></p><p>그리고 마지막으로 pose integration은 mapping이 상대적으로 fine registration이기에 이미 존재하는 mapping에 odometry pose를 쌓는방식으로 한다. 따라서 실시간으로 얻는 pose의 결과는 $T^L_{k+1}T^W_K$가 되는 것이다.</p></ul><h1 id="lego-loam">LeGO-LOAM</h1><p>paper: LeGO-LOAM: Lightweight and Ground-Optimized Lidar Odometry And Mapping on Variable Terrain</p><p>LeGO-LOAM은 ground plane의 존재를 이용해 lightweight한 real time 6DOF pose estimation을 했다고 한다.</p><p>noise filtering을 위해 segmentation을 해서 보다 robust한 결과를 얻었다고 했다.</p><p>computation expense를 줄였지만 성능은 LOAM과 비슷하거나 더 낫다고 했다.</p><ul><li><p>System Overview</p><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%206.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%206.png" data-proofer-ignore></p><p>LeGO LOAM의 전제 시스템은 다섯 부분으로 나뉜다.</p><p>Segmentation 모듈에서 Point Cloud → Range Image → Segmented Point의 과정을 진행하고 Feature Extration 모듈에서 Segmented Cloud로 부터 Feature를 뽑고 이 feature를 이용해 odometry와 mapping을 하고 두 pose를 integration한다고 한다.</p></ul><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%207.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%207.png" data-proofer-ignore></p><ul><li><p>Segmentation</p><p>Point Cloud (그림 a)를 $1800\times16$ 크기의 range image로 변환하고 range image에서의 pixel value는 point의 sensor로 부터의 euclidean distance로 한다. 그리고 Segmentation 이전에 ground extration을 하고서 segmentation을 한다고 하는데 이 ground extration은 column-wise evaluation방법을 통해서 한다고 하는데 이 방법은 range image 상에서 column-wise slope를 이용해서 threshold 미만이면 ground로 판단해서 ground point들을 뽑아낸다고 했다. 이렇게 ground point들의 index를 제외한 나머지 range image에서 image-based segmentation을 한다. 여기서 robustness를 위해 point 갯수가 30개 미만인 segment들은 사용하지 않는다. 이 결과로 segmented point과 groud point (그림 b)를 얻는다.</p><li><p>Feature Extraction</p><p>앞에서 추출한 segmented point와 ground point에서 feature를 뽑는 과정이다. LOAM에서와 같은 smoothness를 정의해서 사용한다.</p>\[c=\frac{1}{|S|||r_i||}||\sum_{j\in S,j\neq i} (r_j-r_i)||\]<p>$S$는 range image상에서 같은 row에 있는 연속적인 point를 사용하였고 LeGO-LOAM 구현 코드에서는 앞뒤로 5개의 point를 사용하였다. 그리고 이 smoothness를 가지고 edge와 planar를 구분한다. (자세한것은 LOAM에서의 설명 참조)</p><p>다른 점은 edge point로 판별되었지만 ground point일 경우는 feature로 사용하지 않으며 $60^{\circ}$씩 6개의 sub-image로 나눠서 edge 와 planar point들을 뽑는다. $\mathbb{F}_e,\mathbb{F}_p$는 6개의 sub image에 있는 모든 feature들의 set이며 \(F_e, F_p\)는 각각의 sub image에 존재하는 feature들의 set이며 \(n_{F_e}, n_{F_p}, n_{\mathbb{F}_e},n_{\mathbb{F}_e}\)는 각각 2, 4, 40, 80으로 정했다. feature extracion을 통해 얻은 feature들은 위의 그림 c와 d에 나타나 있다.</p></ul><p><img data-src="/assets/img/LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%208.png" alt="LOAM,%20Lego-LOAM%20e6abee5cd52d4cfa929a3dd59f13cf36/Untitled%208.png" data-proofer-ignore></p><ul><li><p>Lidar Odometry</p><p>Lidar odometry 모듈에서는 두 개의 연속된 scan 사이의 transformation을 feature들간의 correspondence를 이용해서 구한다. 이를 위해서는 $F^t_e,F^t_p$와 $\mathbb{F}^{t-1}_e,\mathbb{F}^{t-1}_p$사이에서 correspondence를 구하고 이를 optimizaion 해야한다.</p><ul><li><p>Label Matching</p><p>matching의 효율성을 위해서 모든 feature를 match에 이용하는것이 아니라 segmented point에서는 $F^t_e$와 $\mathbb{F}^{t-1}_e$ 사이의 correspondence만 찾고 ground point에서는 $F^t_p$와 $\mathbb{F}^{t-1}_p$사이의 correspondence만 LOAM에서와 같은 방식으로 찾는다.</p><li><p>Two-step LM Optimization</p><p>optimization에서도 속도의 효율성을 높이기 위해서 6-DOF의 transform $[t_x,t_y,t_z,\theta_{roll},\theta_{pitch},\theta_{yaw}]^T$를 한번에 optimization하는 것이 아니라 두 개의 단계로 나눠서 optimization을 진행한다.</p><ol><li>$[t_Z,\theta_{roll},\theta_{pitch}]$를 ground plane을 이용하여 즉 $F^t_p$와 $\mathbb{F}^{t-1}_p$사이의 correspondence의 distance를 줄이는 방향으로 optimization 한다.<li>$[t_x,t_y,\theta_{yaw}]$를 $F_e^t$,$\mathbb{F}^{t-1}_e$ 사이의 distance를 줄이는 방향으로 optimization을 한다.</ol><p>그리고 각각의 과정에서 optimize하는 parameter외의 나머지 parameter는 constraint로 삼아서 optimize한다.</p><p>이렇게 하는 이유는 ground plane만 사용해도 $t_z,\theta_{roll},\theta_{pitch}$를 optimize할 수 있으므로 parameter를 3개씩 나눠서 optimization을 진행해도 optimization이 가능하며 parameter수를 줄이면 LM알고리즘의 특성상 search space가 작아지기 때문에 6개의 한번에 optimization하는것보다 3개씩 두개의 과정으로 나누어 optimization하는것이 더 빠르기 때문이다. 이 방법이 accruracy를 높이는데에 도움이 되었을 뿐만 아니라 실제로 35%정도의 computation time이 줄었다고 한다.</p></ul><li><p>Lidar Mapping</p><p>Lidar Mapping 모듈은 낮은 빈도로 돌아가지만 pose transformation을 refine하기 위해 $\mathbb{F}^t_e, \mathbb{F}^t_p$의 feature들을 주변의 point cloud map $\bar{Q}^{t-1}$과 matching하고 L-M 알고리즘을 사용하여 transformaion을 구하는 모듈이다.</p><p>LeGO-LOAM에서는 LOAM과는 달리 point cloud map을 저장할때 feature set ${\mathbb{F}^t_e,\mathbb{F}^t_p}$도 같이 저장한다. 여기서 $M^{t}={{\mathbb{F}^1_e,\mathbb{F}^1_p},\cdots,{\mathbb{F}^t_e,\mathbb{F}^t_p}}$라고 하면 각각의 $M^t$에 대응하는 pose를 연결짓는 식으로 저장을 한다. 이 $M^{t-1}$로 부터 $\bar{Q}^{t-1}$을 얻는 방법은 두 가지가 있다.</p><ol><li>현재 pose를 기준으로 저장된 feature들 중에서 주변 100m 이내에 있는 모든 pose들의 feature들을 불러오고 이 모든 feature들을 각 pose로 transform하고 합쳐서 surrounding map $\bar{Q}^{t-1}$을 얻는다.<li>LeGO-LOAM을 pose-graph SLAM하고 통합해서 사용한다고 하면 sensor의 pose는 graph의 node로, feature set ${\mathbb{F}^t_e,\mathbb{F}^t_p}$은 각 node의 measurement로 모델링 할 수 있다. 그리고 lidar mapping의 pose estimation drift가 매우 작으므로 단기적으로는 pose의 drift가 없다는 가정하에 최근의 $k$개의 pose 즉 ${{\mathbb{F}^{t-k}_e,\mathbb{F}^{t-k}_p},\cdots,{\mathbb{F}^{t-1}_e,\mathbb{F}^{t-1}_p}}$을 사용해 $\bar{Q}^{t-1}$을 만든다.</ol><p>그리고 odometry와 같은 방식으로 correspondence를 생성한 후에 L-M optimization을 해서 transform을 얻는다. 여기에 추가적으로 loop closure detection을 해서 ICP와 같은 registration을 통해 추가적인 contraint를 얻으면 drift를 줄일 수 있을 것이라 한다.</p></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/slam/'>SLAM</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/slam/" class="post-tag no-text-decoration" >SLAM</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=LOAM%2C+Lego-LOAM+%EC%A0%95%EB%A6%AC+-+I+want+to+know+everything&url=https%3A%2F%2Fsolanian.github.io%2Fposts%2FLOAM%2C-Lego-LOAM%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=LOAM%2C+Lego-LOAM+%EC%A0%95%EB%A6%AC+-+I+want+to+know+everything&u=https%3A%2F%2Fsolanian.github.io%2Fposts%2FLOAM%2C-Lego-LOAM%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fsolanian.github.io%2Fposts%2FLOAM%2C-Lego-LOAM%2F&text=LOAM%2C+Lego-LOAM+%EC%A0%95%EB%A6%AC+-+I+want+to+know+everything" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/why_devcontainer/">Why devcontainer?</a><li><a href="/posts/review-detr/">DETR에서 PETRv2 까지</a><li><a href="/posts/region-growing-segmentation/">Region Growing Segmentation 정리</a><li><a href="/posts/stand_alone_self_attention/">Stand-Alone Self-Attention in Visual Models 정리</a><li><a href="/posts/A_comprehensive_review_of_3D_point_cloud_descriptors/">3D pointcloud descriptors 총 정리</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/pointcloud/">Pointcloud</a> <a class="post-tag" href="/tags/slam/">SLAM</a> <a class="post-tag" href="/tags/vision/">Vision</a> <a class="post-tag" href="/tags/machine-learning/">Machine Learning</a> <a class="post-tag" href="/tags/model/">Model</a> <a class="post-tag" href="/tags/rigid/">Rigid</a> <a class="post-tag" href="/tags/calibration/">calibration</a> <a class="post-tag" href="/tags/diffusion/">Diffusion</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/lidar_iris/"><div class="card-body"> <em class="small" data-ts="1625756400" data-df="ll" > Jul 9, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>LiDAR IRIS 정리</h3><div class="text-muted small"><p> paper: LiDAR Iris for Loop-Closure Detection LiDAR Iris는 빠르고 정확한 loop-closure detection을 위해 LiDAR-Iris image에 LoG-Gabor filter와 thresholding을 적용해서 binary signature image를 feature로 사용한다. 두 이미지의...</p></div></div></a></div><div class="card"> <a href="/posts/robus_place_recognition_using_an_imaging_lidar/"><div class="card-body"> <em class="small" data-ts="1629644400" data-df="ll" > Aug 23, 2021 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Robust Place Recognition Using an Imaging Lidar 정리</h3><div class="text-muted small"><p> paper: Robust Place Recoginition using an Imaging Lidar Introduction 이 논문은 3D point cloud로부터 얻은 intensity range image를 이용해 robust, real-time place recognition을 했다고 한다. ORB feature를 bag-of-word에...</p></div></div></a></div><div class="card"> <a href="/posts/diffusion-det/"><div class="card-body"> <em class="small" data-ts="1670684400" data-df="ll" > Dec 11, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>DiffusionDet 코드까지 깊게 살펴보기</h3><div class="text-muted small"><p> DiffusionDet: Diffusion Model for Object Detection Author: Shoufa Chen Conference / Journal: Arxiv PrePrint Nickname: DiffusionDet Year: 2022 paper: DiffusionDet: Diffusion Model for Object Detec...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/A_comprehensive_review_of_3D_point_cloud_descriptors/" class="btn btn-outline-primary" prompt="Older"><p>3D pointcloud descriptors 총 정리</p></a> <a href="/posts/group_theory/" class="btn btn-outline-primary" prompt="Newer"><p>group theory, lie group, lie algebra</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/solanian">Dongseong Seo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/deep-learning/">Deep Learning</a> <a class="post-tag" href="/tags/pointcloud/">Pointcloud</a> <a class="post-tag" href="/tags/slam/">SLAM</a> <a class="post-tag" href="/tags/vision/">Vision</a> <a class="post-tag" href="/tags/machine-learning/">Machine Learning</a> <a class="post-tag" href="/tags/model/">Model</a> <a class="post-tag" href="/tags/rigid/">Rigid</a> <a class="post-tag" href="/tags/calibration/">calibration</a> <a class="post-tag" href="/tags/diffusion/">Diffusion</a> <a class="post-tag" href="/tags/docker/">Docker</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
